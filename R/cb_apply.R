#' custom *apply function
#'
#' Function designed to handle anything that lapply can but can specify parallel
#' processing, progress bars, output format and more.
#'
#' Ideally, a function that returns a data.frame should be supplied. This gives
#' the user the advantage of specifying the names of the columns in the
#' resulting data.frame.  If the function does not return a data.frame, then
#' column names will be automatically generated.
#'
#' If the output as specified as a data.frame, a column called \code{id} is
#' returned, which contains the names of \code{X}. If no names are present, then
#' they are autogenerated.
#'
#' Parallel processing is carried out by \code{pbapply::mclapply}. Use the
#' \code{parallel} option to switch parallel processing on or off. Only specify
#' the number of cores when really needed as the function will detect the
#' maximum number of available cores.  This makes it easy to rerun the script
#' with a higher number of available cores without having to change the code.
#'
#' A progress bar can be shown in the terminal using an interactive R session or
#' in an .Rout file, if using R CMD BATCH and submitting R scripts for
#' non-interactive completion. Although R Studio supports the progress bar for
#' single process workers, it has a problem showing the progress bar if using
#' parallel processing (see the discussion at
#' http://stackoverflow.com/questions/27314011/mcfork-in-rstudio). In this
#' specific case (R Studio + parallel processing), text updates will be printed
#' to the file `.process`. Use a shell and `tail -f .progress` to see the
#' updates.
#'
#' @param X List of objects to apply over
#' @param FUN. Function to apply
#' @param output Output type. Defaults to 'data.frame', but can also be set to
#'   'list' to suppress rbinding of the list.
#' @param parallel logical; use parallel processing?
#' @param num.cores The number of cores used for parallel processing.  Can be
#'   specified as an integer, or it will guess the number of cores available
#'   with detectCores(). If parallel is FALSE, the input here will be set to 1.
#' @param fill (defaults to TRUE) use plyr::rbind.fill to fill in missing
#'   columns when rbinding together results
#' @param .id a character specifying the name of the column inserted to identify
#'   which element of \code{X} the row in the output data.frame came from.
#'   Defaults to 'id', but set to NULL to suppress creation of this column
#' @param pb logical; use progress bar?
#' @param ... Additional arguments to the function
#' @export
#' @examples
#' X <- as.data.frame(matrix(runif(100),ncol=10))
#'
#' fun. <- function(x) {
#'    Sys.sleep(0.5)
#'    mean(x)
#' }
#'
#' cb_apply(X,fun.)
#'
#' fun. <- function(x) {
#'   Sys.sleep(0.5)
#'   data.frame('mean'=mean(x),'median'=median(x))
#' }
#'
#' cb_apply(X,fun.)
#'
#' # when setting names of input object, function will attempt to assign them to the output in a new column
#' names(X) <- LETTERS[1:10]
#' cb_apply(X,fun.,output='list')
#' cb_apply(X,fun.)
#' # name the id columns something else
#' cb_apply(X,fun.,.id='group')
#' # set .id to NULL to supress the addition of the id columns
#' cb_apply(X,fun.,.id=NULL)

cb_apply <- function(X,FUN.,output='data.frame',fill=TRUE,
                     # names='row.names',
                     pb=TRUE,.id='id',
                     parallel=FALSE,num.cores=NULL,...){

  stopifnot(output %in% c('data.frame','list'),
            num.cores > 0 | is.null(num.cores))
            # is.character(names))

  # figure out way to name output column in data.frame if already doesn't return a data.frame
  # FUN <- function(x,...) {
  #   outtt <- FUN.(x,...)
  #   if (is.data.frame(outtt)) return(outtt)
  #   if (!is.data.frame(outtt)) outtt <- as.data.frame(outtt)
  #   names(outtt) <- paste0('V',1:ncol(outtt))
  #   return(outtt)
  # }

  FUN <- FUN.

  n <- length(X)
  if (!is.vector(X) || is.object(X)) X <- as.list(X)

  # set number of cores
  if (parallel) {
    num.cores <- ifelse(is.null(num.cores),
                        parallel::detectCores(TRUE),
                        num.cores)
    if (is.na(num.cores)) num.cores <- 1
  }
  if(!parallel) num.cores <- 1

   # non parallel progress bar
  if (pb & (num.cores==1)) {
    tmp <- vector('list', n)
    pbb <- progress::progress_bar$new(total=100,
                                      format='...  :what (:percent)   [ ETA: :eta | Elapsed: :elapsed ]',
                                     clear=FALSE,force=TRUE,show_after=0)
    pbb$tick(0)
    for (i in 1:n) {
      pbb$tick(len=100/n,tokens = list(what = paste0('processing ',i,' of ',n)))
      tmp[[i]] <- FUN(X[[i]],...)
    }
  }

  # parallel with progress bar
  if (pb & (num.cores > 1)) {
    if (Sys.getenv("RSTUDIO") == "1") {
      message("progress bar doesn't work in RStudio!\n... follow the file \".progress\" instead")
      wrapFUN <- function(i,...) {
        out <- FUN(X[[i]],...)
        out.percentage <- round(i/n*100,digits=0)
        cat(paste0('   ... processing ',i,' of ',n,' (',out.percentage,'%)','\n'),
            file='.progress',append=FALSE)
        return(out)
      }
      tmp <- parallel::mclapply(1:n,wrapFUN,...,mc.cores=num.cores)
    } else {
      tmp <- mclapply_pb(X,FUN,mccores=num.cores,...)
    }
  }

  # no progress bar
  if ((!pb) & (num.cores > 1)) tmp <- parallel::mclapply(X,FUN,mc.cores=num.cores,...)
  if ((!pb) & (num.cores == 1)) tmp <- lapply(X,FUN,...)

  if (output=='list') tryCatch(names(tmp) <- names(X),error=function(x)NULL)

  # fill function
  if (output=='data.frame') {
    tmp.df.list <- lapply(tmp,as.data.frame)
    fillFUN <- ifelse(fill,plyr::rbind.fill,rbind)
    tmp <- do.call(fillFUN,tmp.df.list)
    # tryCatch(row.names(tmp.df.list) <- names(X),error=function(x)NULL)
    tryCatch(if (!is.null(.id)) tmp[ ,.id] <- rep(names(X),each=nrow(tmp.df.list[[1]])),error=function(x)NULL)
  }

  return(tmp)
}




