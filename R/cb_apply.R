#' custom *apply function
#'
#' Function designed to handle anything that lapply can but can specify parallel
#' processing, progress bars, output format and more.
#'
#' Ideally, a function that returns a data.frame should be supplied. This gives
#' the user the advantage of specifying the names of the columns in the
#' resulting data.frame.  If the function does not return a data.frame, then
#' column names will be automatically generated.
#'
#' Use \code{.id} to control the designation of which input generate which
#' output. Set to \code{NULL} to suppress naming. By default, output lists will
#' be named and output data.frame will have an added column named \code{id}. The
#' name of this inserted column can be changed by specifying a character string.
#' Alternatively, a vector of character strings can be used to manually identify
#' the output (called \code{id} if in a data.frame). Names will be autogenerated
#' even if the input object has incomplete names or no names at all. Note that
#' this also works with functions that return a data.frame with more than one
#' row.
#'
#' Parallel processing is carried out by \code{pbapply::mclapply}. Use the
#' \code{parallel} option to switch parallel processing on or off. Only specify
#' the number of cores when really needed as the function will detect the
#' maximum number of available cores.  This makes it easy to rerun the script
#' with a higher number of available cores without having to change the code.
#'
#' A progress bar can be shown in the terminal using an interactive R session or
#' in an .Rout file, if using R CMD BATCH and submitting R scripts for
#' non-interactive completion. Although R Studio supports the progress bar for
#' single process workers, it has a problem showing the progress bar if using
#' parallel processing (see the discussion at
#' http://stackoverflow.com/questions/27314011/mcfork-in-rstudio). In this
#' specific case (R Studio + parallel processing), text updates will be printed
#' to the file `.process`. Use a shell and `tail -f .progress` to see the
#' updates.
#'
#' @param X List of objects to apply over
#' @param FUN. Function to apply; allows for compact anonymous functions (see
#'   ?purrr::as_function) for details
#' @param output Output type. Defaults to 'data.frame', but can also be set to
#'   'list' to suppress rbinding of the list.
#' @param parallel logical; use parallel processing?
#' @param num.cores The number of cores used for parallel processing.  Can be
#'   specified as an integer, or it will guess the number of cores available
#'   with detectCores(). If parallel is FALSE, the input here will be set to 1.
#' @param cache (defaults to FALSE) cache the results locally in a folder called "cache" using the memoise package
#' @param error.na (defaults to TRUE) use purrr::possibly to replace errors with NA instead of interrupting the process
#' @param fill (defaults to TRUE) use plyr::rbind.fill to fill in missing
#'   columns when rbinding together results
#' @param .id controls add identification of the output object based on the
#'   input object; see details
#' @param pb logical; use progress bar?
#' @param ... Additional arguments to the function
#' @export
#' @examples
#' X <- as.data.frame(matrix(runif(100),ncol=10))
#'
#' fun. <- function(x) {
#'    Sys.sleep(0.5)
#'    mean(x)
#' }
#'
#' cb_apply(X,fun.,cache=TRUE)
#'
#' fun. <- function(x) {
#'   Sys.sleep(0.5)
#'   data.frame('mean'=mean(x),'median'=median(x))
#' }
#'
#' cb_apply(X,fun.)
#'
#' # when setting names of input object, function will attempt to assign them to the output in a new column
#' names(X) <- LETTERS[1:10]
#' cb_apply(X,fun.,output='list')
#' cb_apply(X,fun.)
#' # name the id columns something else
#' cb_apply(X,fun.,.id='group')
#' # specify a new identifier manually
#' cb_apply(X,fun.,.id=LETTERS[11:20])
#' # set .id to NULL to supress the addition of the id columns
#' cb_apply(X,fun.,.id=NULL)
#' # naming still works even if the function returns a data.frame with two rows
#' fun. <- function(x) {
#'   Sys.sleep(0.5)
#'   data.frame('stat'=c(mean(x),median(x)))
#' }
#' cb_apply(X,fun.)

cb_apply <- function(X,FUN.,fill=TRUE,.id='id',output='data.frame',
                     pb=TRUE,parallel=FALSE,cache=FALSE,error.na=TRUE,num.cores=NULL,...){

  stopifnot(output %in% c('data.frame','list'),
            num.cores > 0 | is.null(num.cores))

  FUN <- purrr::as_function(FUN.)

  if (cache) {
    library(memoise)
    fc <- memoise::cache_filesystem('cache')
    FUN <- memoise::memoise(FUN,cache=fc)
  }

  if (error.na) FUN <- purrr::possibly(FUN,otherwise=NA,quiet=FALSE)

  n <- length(X)
  if (!is.vector(X) || is.object(X)) X <- as.list(X)

  # set number of cores
  if (parallel) {
    num.cores <- ifelse(is.null(num.cores),
                        parallel::detectCores(TRUE),
                        num.cores)
    if (is.na(num.cores)) num.cores <- 1
  }
  if(!parallel) num.cores <- 1

   # non parallel progress bar
  if (pb & (num.cores==1)) {
    tmp <- vector('list', n)
    pbb <- progress::progress_bar$new(total=100,
                                      format='...  :what (:percent)   [ ETA: :eta | Elapsed: :elapsed ]',
                                     clear=FALSE,force=TRUE,show_after=0)
    pbb$tick(0)
    for (i in 1:n) {
      pbb$tick(len=100/n,tokens = list(what = paste0('processing ',i,' of ',n)))
      tmp[[i]] <- FUN(X[[i]],...)
    }
  }

  # parallel with progress bar
  if (pb & (num.cores > 1)) {
    if (Sys.getenv("RSTUDIO") == "1") {
      message("progress bar doesn't work in RStudio!\n... follow the file \".progress\" instead")
      wrapFUN <- function(i,...) {
        out <- FUN(X[[i]],...)
        out.percentage <- round(i/n*100,digits=0)
        cat(paste0('   ... processing ',i,' of ',n,' (',out.percentage,'%)','\n'),
            file='.progress',append=FALSE)
        return(out)
      }
      tmp <- parallel::mclapply(1:n,wrapFUN,...,mc.cores=num.cores)
    } else {
      tmp <- mclapply_pb(X,FUN,...,mc.cores=num.cores)
    }
  }

  # no progress bar
  if ((!pb) & (num.cores > 1)) tmp <- parallel::mclapply(X,FUN,mc.cores=num.cores,...)
  if ((!pb) & (num.cores == 1)) tmp <- lapply(X,FUN,...)

  # test for and make names if .id is not NULL
  if (!is.null(.id)) {

    hn <- has_name(X)

    # if has_name returns all TRUE, use names
    if (all(hn)) nms <- names(X)

    # if has_name returns all FALSE, create names
    if (all(!hn)) nms <- make_names(1:n)

    # if has_name returns some TRUE, create names where needed
    if ( (sum(hn)) > 0 & (sum(hn) < n) ) nms <- make_names(X)

    # if .id provided as a vector, use that instead
    if (length(.id) > 1){
      stopifnot(length(.id)==n) # only use if vector of names is the right length
      nms <- .id
      .id <- 'id'
    }
  }

  # name the list only if .id is not NULL
  if (output=='list' & !is.null(.id)) names(tmp) <- nms


  # fill function and insert id column in data.frame
  if (output=='data.frame') {
    tmp.df.list <- lapply(tmp,as.data.frame)
    fillFUN <- ifelse(fill,plyr::rbind.fill,rbind)
    tmp <- do.call(fillFUN,tmp.df.list)
    if (!is.null(.id)) tmp[ ,.id] <- rep(nms,sapply(tmp.df.list,nrow))
  }

  return(tmp)
}




has_name <- function(x) {
  # stolen from https://github.com/hadley/modelr/blob/master/R/utils.R#L25
  nms <- names(x)
  if (is.null(nms)) {
    rep(FALSE, length(x))
  } else {
    !(is.na(nms) | nms == "")
  }
}


make_names <- function(x) {
  which.named <- has_name(x)
  new.names <- make.names(1:sum(!which.named))
  out.names <- vector('character',length(x))
  out.names[which.named] <- names(x)[which.named]
  out.names[!which.named] <- new.names
  return(out.names)
}
