% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cb_apply.R
\name{cb_apply}
\alias{cb_apply}
\title{custom *apply function}
\usage{
cb_apply(X, FUN., output = "data.frame", fill = TRUE, names = "row.names",
  pb = TRUE, parallel = FALSE, num.cores = NULL, ...)
}
\arguments{
\item{X}{List of objects to apply over}

\item{FUN.}{Function to apply}

\item{output}{Output type. Defaults to 'data.frame', but can also be set to
'list' to suppress rbinding of the list.}

\item{fill}{(defaults to FALSE) use plyr::rbind.fill to fill in missing
columns when binding together results}

\item{names}{how to record the names of X in the resulting list or
data.frame. see details}

\item{num.cores}{The number of cores used for parallel processing.  Can be
specified as an integer, or it will guess the number of cores available
with detectCores(). If parallel is FALSE, the input here will be set to 1.}

\item{...}{Additional arguments to the function}
}
\description{
Function designed to handle anything that lapply can but can specify parallel
processing, output naming, progress bars, output format and more.
}
\details{
Ideally, a function that returns a data.frame should be supplied. This gives
the user the advantage of specifying the names of the columns in the
resulting data.frame.  If the function does not return a data.frame, then
column names will be automatically generated ('V1','V2',...).

Three options exist for the names parameter: (1) 'row.names' will attempt to
assign the names of X to the row names of the resulting data.frame. If the
names are not unique, then they will instead be assigned to a column in the
resulting data.frame called "names". (2) any other character string (i.e.
"names" or "id") will assign the names of X to a new column in the resulting
data.frame with that character string. If X does not have a names attribute,
then names will be automatically generated ('V1','V2',...). Lastly, (3) a
vector of character strings will assign this vector as the row.names; it must
have as many elements as the number of rows in the resulting data frame.

A progress bar can be shown in the terminal using an interactive R session or in an
.Rout file, if using R CMD BATCH and submitting R scripts for non-interactive completion.
Although R Studio supports the progress bar for single process workers,
it has a problem showing the progress bar if using parallel processing
(see the discussion at http://stackoverflow.com/questions/27314011/mcfork-in-rstudio).
In this specific case (R Studio + parallel processing),
text updates will be printed to the file `.process`. Use a shell and
`tail -f .progress` to see the updates.
}
\examples{
X <- as.data.frame(matrix(runif(100),ncol=10))

fun. <- function(x) {
   Sys.sleep(0.5)
   mean(x)
}

cb_apply(X,fun.,output='data.frame',parallel=F,names='row.names',pb=F)

cb_apply(X,fun.,output='data.frame',parallel=F,names='id',pb=F)

fun. <- function(x) {
  Sys.sleep(0.5)
  data.frame('mean'=mean(x),'median'=median(x))
}

cb_apply(X,fun.,output='data.frame',parallel=F,names='row.names',pb=F)

cb_apply(X,fun.,output='data.frame',parallel=F,names='id',pb=F)

names(X) <- LETTERS[1:10]

cb_apply(X,fun.,output='data.frame',parallel=F,names='row.names',pb=T)

cb_apply(X,fun.,output='data.frame',parallel=T,num.cores=2,names='row.names',pb=F)

fun. <- function(x) {
  Sys.sleep(0.5)
  data.frame('summ_stat'=c(mean(x),median(x)))
}

cb_apply(X,fun.,output='data.frame',parallel=T,num.cores=2,names='row.names',pb=T)

cb_apply(X,fun.,output='data.frame',parallel=T,num.cores=2,names=paste(rep(names(X),each=2),c('mean','median'),sep='_'),pb=T)
}

