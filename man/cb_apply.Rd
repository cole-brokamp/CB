% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cb_apply.R
\name{cb_apply}
\alias{cb_apply}
\title{custom *apply function}
\usage{
cb_apply(X, FUN., output = "data.frame", fill = TRUE, pb = TRUE,
  .id = "id", parallel = FALSE, num.cores = NULL, ...)
}
\arguments{
\item{X}{List of objects to apply over}

\item{FUN.}{Function to apply}

\item{output}{Output type. Defaults to 'data.frame', but can also be set to
'list' to suppress rbinding of the list.}

\item{fill}{(defaults to TRUE) use plyr::rbind.fill to fill in missing
columns when rbinding together results}

\item{pb}{logical; use progress bar?}

\item{.id}{a character specifying the name of the column inserted to identify
which element of \code{X} the row in the output data.frame came from.
Defaults to 'id', but set to NULL to suppress creation of this column}

\item{parallel}{logical; use parallel processing?}

\item{num.cores}{The number of cores used for parallel processing.  Can be
specified as an integer, or it will guess the number of cores available
with detectCores(). If parallel is FALSE, the input here will be set to 1.}

\item{...}{Additional arguments to the function}
}
\description{
Function designed to handle anything that lapply can but can specify parallel
processing, progress bars, output format and more.
}
\details{
Ideally, a function that returns a data.frame should be supplied. This gives
the user the advantage of specifying the names of the columns in the
resulting data.frame.  If the function does not return a data.frame, then
column names will be automatically generated.

If the output as specified as a data.frame, a column called \code{id} is
returned, which contains the names of \code{X}. If no names are present, then
they are autogenerated.

Parallel processing is carried out by \code{pbapply::mclapply}. Use the
\code{parallel} option to switch parallel processing on or off. Only specify
the number of cores when really needed as the function will detect the
maximum number of available cores.  This makes it easy to rerun the script
with a higher number of available cores without having to change the code.

A progress bar can be shown in the terminal using an interactive R session or
in an .Rout file, if using R CMD BATCH and submitting R scripts for
non-interactive completion. Although R Studio supports the progress bar for
single process workers, it has a problem showing the progress bar if using
parallel processing (see the discussion at
http://stackoverflow.com/questions/27314011/mcfork-in-rstudio). In this
specific case (R Studio + parallel processing), text updates will be printed
to the file `.process`. Use a shell and `tail -f .progress` to see the
updates.
}
\examples{
X <- as.data.frame(matrix(runif(100),ncol=10))

fun. <- function(x) {
   Sys.sleep(0.5)
   mean(x)
}

cb_apply(X,fun.)

fun. <- function(x) {
  Sys.sleep(0.5)
  data.frame('mean'=mean(x),'median'=median(x))
}

cb_apply(X,fun.)

# when setting names of input object, function will attempt to assign them to the output in a new column
names(X) <- LETTERS[1:10]
cb_apply(X,fun.,output='list')
cb_apply(X,fun.)
# name the id columns something else
cb_apply(X,fun.,.id='group')
# set .id to NULL to supress the addition of the id columns
cb_apply(X,fun.,.id=NULL)
}

